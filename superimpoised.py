# -*- coding: utf-8 -*-
"""Superimpoised.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Oop-U1aQVi8Bz71W0UfBbUBwQvlRJGQ0
"""

# import cv2
# import numpy as np
#
# # Load the images with cv2.imread
# image1 = cv2.imread("text.tif")
# image2 = cv2.imread("cameraman.tif")
#
#
# # Blend images (superimpose with a 50% weighting for each image)
# superimposed_image = cv2.addWeighted(image1, 0.5, image2, 0.5, 0)
#
# # Save or show the result
# cv2.imwrite("superimposed_output.tiff", superimposed_image)
# cv2.imshow("Superimposed Image", superimposed_image)
# cv2.waitKey(0)
# cv2.destroyAllWindows()





import cv2
import numpy as np
import matplotlib.pyplot as plt

# Load the 'cameraman' and 'text' images
text = cv2.imread("text.tif", cv2.IMREAD_GRAYSCALE)
cameraman= cv2.imread("cameraman.tif", cv2.IMREAD_GRAYSCALE)

# Resize 'text' image to match 'cameraman' image dimensions if necessary
#text = cv2.resize(text, (cameraman.shape[1], cameraman.shape[0]))

# Superimpose images using the formula: m = uint8(double(c) + 255 * double(t))
superimposed_image = np.uint8(np.clip(np.float64(cameraman) + 255 * np.float64(text), 0, 255))

# Threshold to isolate the text
_, thresholded_image = cv2.threshold(superimposed_image, 200, 255, cv2.THRESH_BINARY)

# Display results
plt.figure(figsize=(18, 6))
plt.subplot(1, 4, 1)
plt.title("Cameraman Image")
plt.imshow(cameraman, cmap='gray')
plt.subplot(1, 4, 2)
plt.title("Text Image")
plt.imshow(text, cmap='gray')
plt.subplot(1, 4, 3)
plt.title("Superimposed Image")
plt.imshow(superimposed_image, cmap='gray')
plt.subplot(1, 4, 4)
plt.title("Thresholded Image (Isolated Text)")
plt.imshow(thresholded_image, cmap='gray')
plt.show()

import cv2
import numpy as np
import matplotlib.pyplot as plt
from scipy import ndimage
from skimage import filters

# Load the 'cameraman' image
cameraman = cv2.imread("cameraman.tif", cv2.IMREAD_GRAYSCALE)

# Roberts Edge Detection
roberts_x = np.array([[1, 0], [0, -1]])
roberts_y = np.array([[0, 1], [-1, 0]])
roberts_edge = np.sqrt(ndimage.convolve(cameraman, roberts_x)**2 + ndimage.convolve(cameraman, roberts_y)**2)

# Prewitt Edge Detection
prewitt_x = filters.prewitt_v(cameraman)
prewitt_y = filters.prewitt_h(cameraman)
prewitt_edge = np.sqrt(prewitt_x**2 + prewitt_y**2)

# Sobel Edge Detection
sobel_x = cv2.Sobel(cameraman, cv2.CV_64F, 1, 0, ksize=3)
sobel_y = cv2.Sobel(cameraman, cv2.CV_64F, 0, 1, ksize=3)
sobel_edge = np.sqrt(sobel_x**2 + sobel_y**2)

# Laplacian Edge Detection
laplacian_edge = cv2.Laplacian(cameraman, cv2.CV_64F)

# Zero-crossings of Laplacian (approximated)
log = cv2.GaussianBlur(cameraman, (5, 5), 0)  # Smooth before finding Laplacian
laplacian_log = cv2.Laplacian(log, cv2.CV_64F)
zero_crossing = np.zeros_like(laplacian_log)
zero_crossing[laplacian_log < 0] = 255  # Highlight negative zero crossings

# Marr-Hildreth (Laplacian of Gaussian)
marr_hildreth = ndimage.gaussian_laplace(cameraman, sigma=2)
marr_hildreth = np.where(marr_hildreth < 100, 255, 0)  # Zero-crossing detection

# Canny Edge Detection
canny_edge = cv2.Canny(cameraman, 100, 200)

# Display Results
plt.figure(figsize=(15, 10))

plt.subplot(3, 3, 1)
plt.title("Original Image")
plt.imshow(cameraman, cmap='gray')

plt.subplot(3, 3, 2)
plt.title("Roberts Edge Detection")
plt.imshow(roberts_edge, cmap='gray')

plt.subplot(3, 3, 3)
plt.title("Prewitt Edge Detection")
plt.imshow(prewitt_edge, cmap='gray')

plt.subplot(3, 3, 4)
plt.title("Sobel Edge Detection")
plt.imshow(sobel_edge, cmap='gray')

plt.subplot(3, 3, 5)
plt.title("Laplacian Edge Detection")
plt.imshow(laplacian_edge, cmap='gray')

plt.subplot(3, 3, 6)
plt.title("Zero-crossings of Laplacian")
plt.imshow(zero_crossing, cmap='gray')

plt.subplot(3, 3, 7)
plt.title("Marr-Hildreth Method")
plt.imshow(marr_hildreth, cmap='gray')

plt.subplot(3, 3, 8)
plt.title("Canny Edge Detection")
plt.imshow(canny_edge, cmap='gray')

plt.tight_layout()
plt.show()